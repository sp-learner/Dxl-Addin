{"version":3,"file":"functions.js","mappings":"yBAkKAA,gBAAgBC,UAAU,OAzJnB,SAAaC,EAAeC,GACjC,OAAOD,EAAQC,CACjB,IAwJAH,gBAAgBC,UAAU,SAjJnB,SAAeG,GACpB,IAAMC,EAAQC,aAAY,WACxB,IAAMC,GAcD,IAAIC,MAAOC,qBAbhBL,EAAWM,UAAUH,EACvB,GAAG,KAEHH,EAAWO,WAAa,WACtBC,cAAcP,EAChB,CACF,IAyIAL,gBAAgBC,UAAU,aAzHnB,SAAmBY,EAAqBT,GAC7C,IAAIU,EAAS,EACPT,EAAQC,aAAY,WACxBQ,GAAUD,EACVT,EAAWM,UAAUI,EACvB,GAAG,KAEHV,EAAWO,WAAa,WACtBC,cAAcP,EAChB,CACF,IAgHAL,gBAAgBC,UAAU,OAxGnB,SAAoBc,GAGzB,OAFAC,QAAQC,IAAIF,GAELA,CACT,G","sources":["webpack://excel-custom-functions/./src/functions/functions.ts"],"sourcesContent":["/* global clearInterval, console, CustomFunctions, setInterval */\n\n/**\n * Adds two numbers.\n * @customfunction\n * @param first First number\n * @param second Second number\n * @returns The sum of the two numbers.\n */\nexport function add(first: number, second: number): number {\n  return first + second;\n}\n\n/**\n * Displays the current time once a second.\n * @customfunction\n * @param invocation Custom function handler\n */\nexport function clock(invocation: CustomFunctions.StreamingInvocation<string>): void {\n  const timer = setInterval(() => {\n    const time = currentTime();\n    invocation.setResult(time);\n  }, 1000);\n\n  invocation.onCanceled = () => {\n    clearInterval(timer);\n  };\n}\n\n/**\n * Returns the current time.\n * @returns String with the current time formatted for the current locale.\n */\nexport function currentTime(): string {\n  return new Date().toLocaleTimeString();\n}\n\n/**\n * Increments a value once a second.\n * @customfunction\n * @param incrementBy Amount to increment\n * @param invocation Custom function handler\n */\nexport function increment(incrementBy: number, invocation: CustomFunctions.StreamingInvocation<number>): void {\n  let result = 0;\n  const timer = setInterval(() => {\n    result += incrementBy;\n    invocation.setResult(result);\n  }, 1000);\n\n  invocation.onCanceled = () => {\n    clearInterval(timer);\n  };\n}\n\n/**\n * Writes a message to console.log().\n * @customfunction LOG\n * @param message String to write.\n * @returns String to write.\n */\nexport function logMessage(message: string): string {\n  console.log(message);\n\n  return message;\n}\n\n// async function PutFormula() {\n//   console.log(\"Applying fully dynamic formulas...\");\n\n//   await Excel.run(async (context) => {\n//     const sheet = context.workbook.worksheets.getActiveWorksheet();\n//     const range = sheet.getUsedRange();\n//     range.load(\"values\");\n//     await context.sync();\n\n//     let data = range.values;\n//     if (data.length === 0 || data[0].length === 0) {\n//       console.error(\"No data found in the sheet.\");\n//       return;\n//     }\n\n//     // Header Row Function\n//     let headerRowIndex = -1;\n//     for (let i = 0; i < data.length; i++) {\n//       if (data[i].some(cell => typeof cell === \"string\" && cell.trim() !== \"\")) {\n//         headerRowIndex = i;\n//         break;\n//       }\n//     }\n\n//     if (headerRowIndex === -1) {\n//       console.error(\"No valid header row found.\");\n//       return;\n//     }\n\n//     let headers = data[headerRowIndex].map(header => header ? header.toString().trim().toLowerCase() : \"\");\n\n//     //Synonyms\n//     const Synonyms = {\n//       WGT: [\"TOTAL CTS\",\"TotalCts\", \"Weight R\",\"weigh\", \"Cts#\", \"SIZE#\",\"Wt#\", \"Car\", \"Cara\", \"Carat\", \"CARATS\", \"Crt\", \"Crts\", \"CRTWT\", \"CT\", \"Ct.\", \"Cts\", \"Cts.\", \"POLISE\" ,\"CT\" ,\"Size\", \"SIZE.\" ,\"Weight\", \"Weight ??\", \"Wgt\" ,\"WHT.\", \"WT\", \"Wt.\"],\n//       RATE: [\"BaseRate\", \"Disc Price\",\" Full Rap Price\", \"List\", \"List Price\", \"List Price ????\", \"List Rate\", \"LiveRAP\", \"NEW RAP\", \"Orap\", \"price\", \"R.PRICE\", \"Rap\", \"Rap $\", \"Rap $/CT\", \"Rap List\", \"Rap Price\", \"Rap Price($)\", \"Rap Rate\", \"RAP RTE\", \"Rap$\", \"RAP($)\", \"Rap-Price\", \"RAP.\", \"Rap.\", \"Price\", \"Rap.($)\", \"Rap/Price\", \"Rap_per_Crt\", \"RAP_PRICE\", \"Rapa\", \"Rapa Rate\", \"Rapa_Rate\", \"rapaport\", \"RAPAPORT_RATE\", \"RapaportPrice\", \"RapaRate\", \"RapDown\", \"Rape\", \"RapList\", \"RapNet Price\", \"rapnetcaratprice\", \"RapNetPrice\", \"RAPO\", \"RAPPLIST\", \"rapprice\", \"RapRat\", \"RapRate\", \"RapRice\", \"RapRte\", \"Rate\", \"repRate\"],\n//       DISC_PER: [\"%\",\" % Back\",\" % BELOW\", \"%Rap\", \"Asking Disc. %\", \"Back\", \"BACK %\", \"Back (-%)\", \"Back %\", \"Back -%\", \"Back%\", \"Base Off %\", \"Base Off%\", \"CBack\", \"DIC.\", \"DIS\", \"Dis %\", \"Dis%\", \"DIS.\", \"Disc\", \"Disc %\", \"Disc%\", \"Disc(%)\", \"DISC.\", \"Disc/Pre\", \"DISC_PER\", \"Disco%\", \"DISCOUNT\", \"Discount %\",\"Discount % ??\", \"Discount%\", \"Discprct\", \"F disc\", \"Fair/Last Bid %\", \"Final %\", \"Final Disc%\", \"final_discount\", \"ListDisc%\", \"Net %\", \"New Rap%\", \"Off %\", \"Off%\", \"Offer Disc.(%)\", \"OffPer\", \"Price\", \"R.Dn\", \"Rap %\", \"RAP DIS\", \"Rap Disc\", \"Rap Disc %\", \"Rap Discount\", \"Rap%\", \"Rap.%\", \"RAP_DISCOUNT\", \"rap_per\", \"RapDis\", \"RapDown\", \"rapnet\", \"Rapnet\", \"Discount %\", \"RapNet Back\", \"Rapnet Discount\", \"Rapnet Discount%\", \"rapnetdiscount\", \"RapnetDiscountPercent\", \"RapOff\", \"RP Disc\", \"saleback\", \"SaleDis\", \"SaleDisc\", \"Selling Disc\", \"User Disc\", \"VDisc %\",\" WebsiteDiscount\", \"Rapdisc\"],\n//       Value: [\"value\", \"rapvalue\", \"rapaport value\", \"r.value\", \"val\", \"RapVlu\"],\n//     };\n\n//     function findColumnIndex(synonymsArray) {\n//       return headers.findIndex((header) => synonymsArray.some((synonym) => header.includes(synonym.toLowerCase())));\n//     }\n\n//     const wgtIndex = findColumnIndex(Synonyms.WGT);\n//     const rateIndex = findColumnIndex(Synonyms.RATE);\n//     const discPerIndex = findColumnIndex(Synonyms.DISC_PER);\n//     const valueIndex = findColumnIndex(Synonyms.Value);\n//     const netRateIndex = headers.indexOf(\"net_rate\");\n//     const netValueIndex = headers.indexOf(\"net_value\");\n\n//     if ([wgtIndex, rateIndex, discPerIndex, valueIndex, netRateIndex, netValueIndex].includes(-1)) {\n//       console.error(\"Required columns not found.\");\n//       return;\n//     }\n\n//     //for finding Column & Row\n//     const wgt = getColumnLetter(wgtIndex);\n//     const rate = getColumnLetter(rateIndex);\n//     const discper = getColumnLetter(discPerIndex);\n//     const netRate = getColumnLetter(netRateIndex);\n\n//     for (let i = headerRowIndex + 1; i < data.length; i++) {\n//       const rowNum = i + 1;\n\n//       //formulas & Calculations\n//       const valueFormula = `=${wgt}${rowNum}*${rate}${rowNum}`;\n//       const netRateFormula = `=${rate}${rowNum}+((${rate}${rowNum}*${discper}${rowNum})/100)`;\n//       const netValueFormula = `=${wgt}${rowNum}*${netRate}${rowNum}`;\n\n//       data[i][valueIndex] = valueFormula;\n//       data[i][netRateIndex] = netRateFormula;\n//       data[i][netValueIndex] = netValueFormula;\n//     }\n\n//     range.formulas = data;\n//     await context.sync();\n//     console.log(\"Fully dynamic formulas applied!\");\n//   }).catch(error => console.error(\"Error in PutFormula:\", error));\n// }\n\n// function getColumnLetter(index) {\n//   if (index < 0) return \"\";\n//   let columnLetter = \"\";\n//   let tempIndex = index;\n\n//   while (tempIndex >= 0) {\n//     columnLetter = String.fromCharCode((tempIndex % 26) + 65) + columnLetter;\n//     tempIndex = Math.floor(tempIndex / 26) - 1;\n//   }\n\n//   return columnLetter;\n// }\n\n// window.PutFormula = PutFormula;\n\nCustomFunctions.associate(\"ADD\", add);\nCustomFunctions.associate(\"CLOCK\", clock);\nCustomFunctions.associate(\"INCREMENT\", increment);\nCustomFunctions.associate(\"LOG\", logMessage);"],"names":["CustomFunctions","associate","first","second","invocation","timer","setInterval","time","Date","toLocaleTimeString","setResult","onCanceled","clearInterval","incrementBy","result","message","console","log"],"sourceRoot":""}